* refs
started here:
https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/

* resume at section 4
at the later of the two appearances of this phrase
go curr@(Next attr) = let
* questions
** Why are RAlgebra and RAlgebra' equivalent?
https://blog.sumtypeofway.com/recursion-schemes-part-iii-folds-in-context/
** asked
https://github.com/patrickt/recschemes/issues/5
*** What's up with the cata laws?
 In [part 2](https://blog.sumtypeofway.com/recursion-schemes-part-2/) I'm confused by the laws. The first is stated as an equation: `cata In = id`. That's clear. But the second is stated as an implication:

 ```
 -- given alg :: f a -> a
 -- and func  :: f a -> f
 cata (alg >>> fmap func) =>
    (cata alg) >>> func
 ```

 Is that `=>` symbol supposed to be `=`?

 And the third is even stranger:

 ```
 -- given alg  :: f a -> a
 -- and func :: f a -> g a
 cata (f >>> In) >>> cata g
    ==> cata (f >>> g)
 ```

 Is that `==>` symbol again supposed to be `=`? And why does it stipulate types for `alg` and `func`, without ever using them?
*** The code for para generalizing cata appears to be broken
 (In section 3 of the blog series.)
 It is this:
   cata' :: Functor f => Algebra f a -> Term f -> a
   cata' = para'' (const f)
 But f is not defined, except as a type constraint.
*** Section III claims Section II defined ana
 "In the previous post, we defined ana, the anamorphism"
 (and section 1 makes a similar claim).
